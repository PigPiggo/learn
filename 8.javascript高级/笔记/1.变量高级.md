## 变量高级
1. 变量：内存中用于存放数据的标识；
- JS是弱类型的，这个变量中存储的数据类型和声明方式没有关系；
2. js数据的类型；
- 基本类型；5+1（symbol，占时没用）
- 引用类型；
3. 变量类型的检查；
- typeof，但是typeof不能检测出数组和对象的区别；
- 如何检测一个变量是否为数组；
    - arr.isArray(变量)；//true/false
    - 变量 instanceof Array;//true/false
- null是基本类型，但是typeof打印出来是object；
4. 变量的内存分配；
- 基本类型：
    - 保存在栈内存中，在内存中占有固定的大小和空间，一般称为按值访问，按值传递；
    - 栈内存是数组结构，有序，先进后出；
- 引用类型：
    - 保存在堆内存中，内存地址保存在栈内存中
    - 地址指向数据，数据存放在堆内存中，按用用访问，按引用传递；
5. 变量的复制
- 基本类型
    - 值拷贝，把原来的值复制一份，给新的变量，不会影响原来的值；
```
var a = 100;
var b = a ;
console.log(a);
console.log(a===b);//true
```
- 引用类型
    - 把原来的地址（引用）复制出来，赋值给新变量，这样新的变量和原来的变量就指向同一个真正的数据；改变新变量，会影响原来的数据；
```
var user1 = {
    name:"李寻欢",
    age:32,
}
var user2 = user1;
console.log(user1 === user2);//true 
```
6. 一切皆对象
- js中，其实所有数据，都是对象，所有数据都是由内置对象构造出来的；
- 注意：其实js中所有的数据类型都是object构造出来的；
- console.dir可以打印出引用数据的所有方法和属性；
7. 对象访问属性的两种方法（动态添加和访问）
- 对象.属性名
    - 不能识别变量；
- 对象['属性名']
    - 可以识别变量；
8. 传递参数
- 基本类型，实参传递给形参的是值的拷贝；
- 引用类型，实参传递给形参的是地址（“引用”）的拷贝；
- 问题：只要是引用类型的数据复制，就会造成共享数据的问题，修改其中一份就会影响原来对象；
    - 解决：对象的浅拷贝和深拷贝；
10. 浅拷贝和深拷贝
- 浅拷贝：只拷贝对象一层的属性；
    - for in：循环方法
    - Object.assing({},源对象1，源对象2，...)：对象合并方法；
    - 第二层的改变会影响源对象；
- 深拷贝：拷贝对象所有层级的属性；
    - JSON方法；
        1. JSON.stringfy();
        2. JSON.parse();
11. 作用域（词法作用域）
- js作用域：全局作用域 局部作用域 块级作用域（es6才有）；
- 概念：js标识符可以访问的“范围”；
    - js标识符：使用var let const声明的变量 或者用function声明的函数
-  作用域查找规则，有内到外，先从自己找，再从上一层作用域找，直到找到位置；
- 作用域在写代码的时候就决定了，无论如何调用都不会改变；
12. 对象字面量和json之间的区别
- 对象的键名可以不加引号，json格式（.js）的数据必须加引号；
- 对象字面量是js的一种数据类型（object），主要以键值对（key:value）形式存在；
- JSON是一种数据格式，以后工作中前端发送ajax，后端响应JSON；
- JSON同时还是一个非常重要的内置对象，有两个重要方法
    - JSON.stringify() 对象转字符串；
    - JSON.parse()  字符串转对象；
13. es6的两个关键字
- es5中没有块级作用域；
- var:
    1. 没有块级作用域
    2. 在相同作用域（代码块）中可以被重新声明；
    3. var声明的全局变量属于window对象，可以用window.xx打印
    4. var声明的变量会提升到代码最前面，然后在该代码行给变量赋值；
- let：
    1. 有块级作用域，在没有块级作用域的时候，let会在script标签中创建一个块级作用域
    2. 在相同作用域中（代码块）不可以被重新声明；
    3. let声明的全局变量不属于window对象，不可以用window.xx打印
    4. let声明的变量不会提升到代码最前面 
- const：
    1. 有块级作用域，在没有块级作用域的时候，const会在script标签中创建一个块级作用域用域的时候，const会在script标签中创建一个块级作用域
    2. 在相同作用域中（代码块）不可以被重新声明；
    3. const声明的全局变量不属于window对象，不可以用window.xx打印 
    4. const声明不会提升到代码最前面
    5. const在声明变量的时候必须立刻赋值；
- 注意
    - 在for循环中，var，let不报错，const报错；因为for循环相当于在同一个作用域中修改i的值，const声明的量不能改变，所以会报错；
    - 在for in 中三个都不报错，因为for in循环相当于在分别在几个不同的作用域中创建i并给i赋值，所以被不会报错；
    - let和const创建的引用类型数据，其栈内存中的地址不能被修改，但是堆内存中的的变量可以被增，删，改；
14. 编译器原理和变量声明的提升
- 编译器原理
    1. js代码执行分为“预编译”和“解释执行”两个阶段；
    2. 在“预编译”阶段，会把所有使用var声明的变量和使用function声明的函数提升到`当前作用域`顶端；
    3. 使用var声明的变量只是提升声明，赋值保留在原位；
    4. 使用function声明的函数，提升的是整个函数体；